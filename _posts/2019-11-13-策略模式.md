---
layout: post
title: 策略模式
---
# 策略模式仅仅封装算法（包括添加 & 删除），但策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定  

# 实例讲解  
```
public abstract class Strategy {  

    public abstract void Show()；
}
```  
> 
```
//为春节准备的促销活动A
class StrategyA extends Strategy{

    @Override
    public void show() {
        System.out.println("为春节准备的促销活动A");
    }
}

//为中秋节准备的促销活动B
class StrategyB extends Strategy{

    @Override
    public void show() {
        System.out.println("为中秋节准备的促销活动B");
    }
}

//为圣诞节准备的促销活动C
class StrategyC extends Strategy{

    @Override
    public void show() {
        System.out.println("为圣诞节准备的促销活动C");
    }
}
```
> 
```
class Context_SalesMan{
//持有抽象策略角色的引用
    private Strategy strategy;

    //生成销售员实例时告诉销售员什么节日（构造方法）
    //使得让销售员根据传入的参数（节日）选择促销活动（这里使用一个简单的工厂模式）
    public SalesMan(String festival) {
        switch ( festival) {
            //春节就使用春节促销活动
            case "A":
                strategy = new StrategyA();
                break;
            //中秋节就使用中秋节促销活动
            case "B":
                strategy = new StrategyB();
                break;
            //圣诞节就使用圣诞节促销活动
            case "C":
                strategy = new StrategyC();
                break;
        }

    }

    //向客户展示促销活动
    public void SalesManShow(){
        strategy.show();
    }

}
```  
> 
```
public class StrategyPattern{
  public static void main(String[] args){

        Context_SalesMan mSalesMan ;

        //春节来了，使用春节促销活动
        System.out.println("对于春节：");
        mSalesMan =  Context_SalesMan SalesMan("A");
        mSalesMan.SalesManShow();
        
        
        //中秋节来了，使用中秋节促销活动
        System.out.println("对于中秋节：");
        mSalesMan =  Context_SalesMan SalesMan("B");
        mSalesMan.SalesManShow();

        //圣诞节来了，使用圣诞节促销活动
        System.out.println("对于圣诞节：");
        mSalesMan =  Context_SalesMan SalesMan("C");
        mSalesMan.SalesManShow();  
  }   
}
```  
# 1.优点  
* 策略类之间可以自由切换,由于策略类都实现同一个接口，所以使它们之间可以自由切换。  
* 易于扩展,增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“  
* 避免使用多重条件选择语句（if else），充分体现面向对象设计思想。  
# 2.缺点  
* 客户端必须知道所有的策略类，并自行决定使用哪一个策略类  
* 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。
