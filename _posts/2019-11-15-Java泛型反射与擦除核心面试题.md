---
layout: post
title: Java泛型反射与擦除核心面试题(5)
---
# 问：下面两个代码片段有问题吗，为什么？  
```
//Part 1
List<Object> obj = new ArrayList<Long>();
obj.add("I love Android!");

//Part 2
Object[] objArray = new Long[1];
objArray[0] = "I love Android!";
```

***答：***上面 Part 1 编译出错，Part 2 编译 OK，运行出错。
因为 List<Object> 和 ArrayList<Long> 没有继承关系，而 ***Java 的数组是在运行时类型检查的。***  

# 问：如何把 int 值放入 ArrayList<String> list = new ArrayList<String>(); 的 list 列表中？  
***答：***本题实质为泛型的擦除，不过答案比较多，常见的一种是通过兼容性，一种是通过反射的特性来处理。
****通过泛型擦除兼容性实现如下****

```
ArrayList<String> list = new ArrayList<String>();
ArrayList list1 = list;
list1.add(12);
System.out.println(list1.get(0));
```

****通过反射实现如下：****

```
ArrayList<String> list = new ArrayList<String>();
Class clazz = list.getClass();
Method m = clazz.getMethod("add", Object.class);m.invoke(list, 100);
```

# 问：泛型擦除到底擦除了哪些信息？  
***答：***这道题就比较有意思和深度了，很多没有深入了解泛型的人可能听到这道题就觉得题出的有问题，因为在他们的认识里泛型信息都被擦除了，怎么还分擦除了哪些信息？难道还分情况？答案是确定的，泛型擦除其实是分情况擦除的，不是完全擦除，一定要消除这个误区。
Java 在编译时会在字节码里指令集之外的地方保留部分泛型信息，泛型接口、类、方法定义上的所有泛型、成员变量声明处的泛型都会被保留类型信息，其他地方的泛型信息都会被擦除。
感兴趣的可以自己编写各种场景的泛型代码然后编译后反编译查看即可发现。

# 问：既然泛型类型在编译时就被擦除了，那类似 Gson 这种 json 解析框架是如何解析数据到泛型类型 Bean 结构的呢？  

***答：***本题其实一箭双雕，即考察了对于 Gson 框架是否熟悉又考察了 Java 泛型与反射的关系及泛型的实质。
由于在运行期间无法通过 getClass() 得知 T 的具体类型，所以 Gson 通过借助 TypeToken 类来解决这个问题，使用样例如下：

```
ArrayList<String> list = new ArrayList<String>();
list.add("java");

Type type = new TypeToken<ArrayList<String>>(){}.getType();

String gStr = new Gson().toJson(list, type);

ArrayList<String> gList = new Gson().fromJson(gStr, type);
```

可以看到 TypeToken 的使用非常简单，只用将需要获取类型的泛型类作为 TypeToken 的泛型参数构造一个匿名的子类就可以通过 getType() 方法获取到我们使用的泛型类的泛型参数类型。

通过上面的使用样例我们会发现使用 Gson 解析转换的 Bean 不存在特殊的构造方法，因此可以排除在泛型类的构造方法中显示地传入泛型类的 Class 类型作为这个泛型类的私有属性来保存泛型类的类型信息的实现方案，所以通过源码分析发现 Gson 使用了另一种方式来获取泛型的类型参数，其方法依赖 Java 的 Class 字节码中存储的泛型参数信息，Java 的泛型机制虽然在编译期间进行了擦除，但是在编译 Java 源代码成 class 文件中还是保存了泛型相关的信息，这些信息被保存在 class 字节码的常量池中，使用了泛型的代码处会生成一个 signature 签名字段，通过签名 signature 字段指明这个常量池的地址，JDK 提供了方法去读取这些泛型信息的方法，然后再借助反射就可以获得泛型参数的具体类型，具体实现原理如下：

```
Type mySuperClass = new ArrayList<String>(){}.getClass().getGenericSuperclass();
Type type = ((ParameterizedType) mySuperClass).getActualTypeArguments()[0];
System.out.println(type);
```

所以获取泛型参数类型的实质就是通过 Class 类的 getGenericSuperClass() 方法返回一个 ParameterizedType 对象（对于 Object、接口和原始类型返回 null，对于数组 class 返回 Object.class），ParameterizedType 表示带有泛型参数类型的 Java 类型，JDK1.5 引入泛型后 Java 中所有的 Class 都实现了 Type 接口，ParameterizedType 继承了 Type 接口，所有包含泛型的 Class 类都会自动实现这个接口。

关于 class 文件中存储泛型参数类型的详细信息可以参考：http://stackoverflow.com/questions/937933/where-are-generic-types-stored-in-java-class-files  

# 问：下面程序的输出是什么？为什么？

```
public class Demo {
    public static void main(String[] args) throws Exception {
        ParameterizedType type = (ParameterizedType) Bar.class.getGenericSuperclass();
        System.out.println(type.getActualTypeArguments()[0]);

        ParameterizedType fieldType = (ParameterizedType) Foo.class.getField("children").getGenericType();
        System.out.println(fieldType.getActualTypeArguments()[0]);
        ParameterizedType paramType = (ParameterizedType) Foo.class.getMethod("foo", List.class).getGenericParameterTypes()[0];
        System.out.println(paramType.getActualTypeArguments()[0]);
        System.out.println(Foo.class.getTypeParameters()[0].getBounds()[0]);
    }
    class Foo<T extends CharSequence> {
        public List<Bar> children = new ArrayList<Bar>();
        public List<StringBuilder> foo(List<String> foo){
            return null;
        }
        public void bar(List<? extends String> param) {
            //empty
        }
    }
    class Bar extends Foo<String> {}
}
```
***答：***其运行结果如下。
* class java.lang.String  
* class Demo$Bar  
* class java.lang.String  
* interface java.lang.CharSequence

通过上面例子会发现泛型类型的每一个类型参数都被保留了，而且在运行期可以通过反射机制获取到，因为泛型的擦除机制实际上擦除的是除结构化信息外的所有东西（结构化信息指与类结构相关的信息，而不是与程序执行流程有关的，即与类及其字段和方法的类型参数相关的元数据都会被保留下来通过反射获取到）。

