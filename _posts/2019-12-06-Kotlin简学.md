Kotlin
# 1.导入
如果出现名字冲突，可以使用 as 关键字在本地重命名冲突项来消歧义：
import org.example.Message // Message 可访问
import org.test.Message as testMessage // testMessage 代表“org.test.Message”
关键字 import 并不仅限于导入类；也可用它来导入其他声明：

* 顶层函数及属性；
* 在对象声明中声明的函数和属性;
* 枚举常量。

# 2.控制流：if、when、for、while
<font color="#dd00">A.if是一个表达式，即它会返回一个值</font>

```
val max = if (a > b) a else b
val max = if (a > b) {   //if 的分支可以是代码块,最后的表达式作为该块的值
    print("Choose a")
    a
} else {
    print("Choose b")
    b
}
```

<font color="#dd00">B. when</font>

      1.如果被当做表达式， 符合条件的分支的值就是整个表达式的值，则必须有 else 分支,除非编译器能够检测出所有的可能情况都已经覆盖了
      2.如果当做语句使用， 则忽略个别分支的值
```
when (x) {
    0, 1 -> print("x == 0 or x == 1")
    in 2..10 -> print("x is in the range")
    else -> print("otherwise")
}

fun hasPrefix(x: Any) = when(x) {
    is String -> x.startsWith("prefix")
    else -> false
}
```
来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：
```
when {
    x.isOdd() -> print("x is odd")
    x.isEven() -> print("x is even")
    else -> print("x is funny")
}
```
# 3.for
循环可以对任何提供迭代器（iterator）的对象进行遍历
```
for (item in collection) print(item)
for (item: Int in ints) {
    // ……
}
```
在数字区间上迭代,被编译为并不创建迭代器的基于索引的循环
```
for (i in 1..3) {
    println(i)
}
for (i in 6 downTo 0 step 2) {
    println(i)
}
```
通过索引遍历一个数组或者一个 list
```
for ((index, value) in array.withIndex()) {
    println("the element at $index is $value")
}
```
# 4.返回与跳转
 ```
 val s = person.name ?: return  如果name是null就return不执行(这种方式可用于初始化的时候 保证不为空)
```
任何表达式都可以用标签（label）来标记
```
loop@ for (i in 1..100) {
    for (j in 1..100) {
        if (……) break@loop
    }
}
```
标签限制的 return 允许我们从外层函数返回
```
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach lit@{
        if (it == 3) return@lit // 局部返回到该 lambda 表达式的调用者，即 forEach 循环
        print(it)
    }
    print(" done with explicit label")
}
```
或者，我们用一个匿名函数替代 lambda 表达式
```
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {
        if (value == 3) return  // 局部返回到匿名函数的调用者，即 forEach 循环
        print(value)
    })
    print(" done with anonymous function")
}
```

当要返一个回值的时候，解析器优先选用标签限制的 return
return@a 1   意为“从标签 @a 返回 1”

# 5.类
<font color="#dd00">A.一个类可以有一个主构造函数以及一个或多个次构造函数(主构造函数在类名（与可选的类型参数）后。)
class Person constructor(firstName: String)</font>

如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字。
class Person(firstName: String) { /*……*/ }
主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中。

<font color="#dd00">B.实例初始化期间，初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起：</font>
```
class InitOrderDemo(name: String) {
    val firstProperty = "First property: $name".also(::println)
    
    init {
        println("First initializer block that prints ${name}")
    }
    
    val secondProperty = "Second property: ${name.length}".also(::println)
    
    init {
        println("Second initializer block that prints ${name.length}")
    }
}
```
<font color="#dd00">C.如果构造函数有注解或可见性修饰符，这个 constructor 关键字是必需的，并且这些修饰符在它前面：</font>
```
class Customer public @Inject constructor(name: String) { /*……*/ }
```
<font color="#dd00">D.类也可以声明前缀有 constructor的次构造函数：</font>
```
class Person {
    constructor(parent: Person) { //次构造函数 由于无主构造函数不需委托主构造函数
    }
}
```
<font color="#dd00">E.如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 this 关键字即可</font>
```
class Person(val name: String) {
    var children: MutableList<Person> = mutableListOf<Person>();
    constructor(name: String, parent: Person) : this(name) {
        parent.children.add(this)
    }
}
```
<font color="#dd00">F.请注意，初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块：</font>
```
  class Constructors {
    init {
        println("Init block")
    }

    constructor(i: Int) {
        println("Constructor")
    }
}
```

<font color="#dd00">G.如果你不希望你的类有一个公有构造函数，你需要声明一个带有非默认可见性的空的主构造函数：</font>
```
class DontCreateMe private constructor () { /*……*/ }
```
<font color="#dd00">H.注意：在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值</font>
```
class Customer(val customerName: String = "")
```
<font color="#dd00">I.如果派生类有一个主构造函数，其基类型可以（并且必须） 用基类的主构造函数参数就地初始化。
如果派生类没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点</font>
```
class MyView : View {
    constructor(ctx: Context) : super(ctx)

    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
}
```
<font color="#dd00">J.如果函数没有标注 open 如 Shape.fill()，那么子类中不允许定义相同签名的函数， 不论加不加 override.标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用 final 关键字：</font>
```
open class Rectangle() : Shape() {
    final override fun draw() { /*……*/ }
}
```
<font color="#dd00">K.属性覆盖与方法覆盖类似,在超类中声明(加open)然后在派生类中重新声明的属性必须以 override 开头,可以用一个 var 属性覆盖一个 val 属性，但反之则不行.因为一个 val 属性本质上声明了一个 get 方法， 而将其覆盖为 var 只是在子类中额外声明一个 set 方法。</font>
```
class Polygon : Shape {
    override var vertexCount: Int = 0  // 以后可以设置为任何数
}
```
<font color="#dd00">M.派生类初始化顺序</font>  
在构造派生类的新实例的过程中，第一步完成其基类的初始化（在之前只有对基类构造函数参数的求值），因此发生在派生类的初始化逻辑运行之前
```
open class Base(val name: String) {

    init { println("Initializing Base") }

    open val size: Int = 
        name.length.also { println("Initializing size in Base: $it") }
}

class Derived(
    name: String,
    val lastName: String
) : Base(name.capitalize().also { println("Argument for Base: $it") }) {

    init { println("Initializing Derived") }

    override val size: Int =
        (super.size + lastName.length).also { println("Initializing size in Derived: $it") }
}
```
这意味着，基类构造函数执行时，派生类中声明或覆盖的属性都还没有初始化。如果在基类初始化逻辑中（直接或通过另一个覆盖的 open 成员的实现间接）使用了任何一个这种属性，那么都可能导致不正确的行为或运行时故障。设计一个基类时，应该避免在构造函数、属性初始化器以及 init 块中使用 open 成员。

# 6.属性
<font color="#dd00">A.为属性定义自定义的访问器</font>
```
var stringRepresentation: String
    get() = this.toString()
    set(value) {
        setDataFromString(value) // 解析字符串并赋值给其他属性
        _stringRepresentation = value
    }
````
# 7.接口
接口可以既包含抽象方法的声明也包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。
```
interface MyInterface {
    val prop: Int // 抽象的

    val propertyWithImplementation: String
        get() = "foo"

    fun foo() {
        print(prop)
    }
}

class Child : MyInterface {
    override val prop: Int = 29
}

解决覆盖冲突
interface A {
    fun foo() { print("A") }
    fun bar()
}

interface B {
    fun foo() { print("B") }
    fun bar() { print("bar") }
}

class C : A {
    override fun bar() { print("bar") }
}

class D : A, B {
    override fun foo() {
        super<A>.foo()
        super<B>.foo()
    }

    override fun bar() {
        super<B>.bar()
    }
}
```
我们从 A 和 B 派生 D，我们需要实现我们从多个接口继承的所有方法，并指明 D 应该如何实现它们。这一规则既适用于继承单个实现（bar()）的方法也适用于继承多个实现（foo()）的方法。

# 8.扩展
<font color="#dd00">A.扩展是静态解析的,扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。</font>
```
fun Example.printFunctionType() { println("Extension function") }
```
<font color="#dd00">B.可空接收者,可以为可空的接收者类型定义扩展</font>
```
fun Any?.toString(): String {
    if (this == null) return "null"
    // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()
    // 解析为 Any 类的成员函数
    return toString()
}
```
<font color="#dd00">C.扩展属性,由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就是为什么扩展属性不能有初始化器。他们的行为只能由显式提供的 getters/setters 定义</font>
```
val <T> List<T>.lastIndex: Int
    get() = size - 1
```
# 9.数据类
```
data class User(val name: String, val age: Int)
data class Person(val name: String) {
    var age: Int = 0
}
```
# 10.密封类
密封类用来表示受限的类继承结构：当一个值为有限几种的类型、而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。
要声明一个密封类，需要在类名前面添加 sealed 修饰符虽然密封类也可以有子类，但是所有子类都必须在与密封类自身相同的文件中声明
```
sealed class Expr
data class Const(val number: Double) : Expr()
data class Sum(val e1: Expr, val e2: Expr) : Expr()
object NotANumber : Expr()
```
使用密封类的关键好处在于使用 when 表达式 的时候，如果能够验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了
```
fun eval(expr: Expr): Double = when(expr) {
    is Const -> expr.number
    is Sum -> eval(expr.e1) + eval(expr.e2)
    NotANumber -> Double.NaN
    // 不再需要 `else` 子句，因为我们已经覆盖了所有的情况
}
```
# 11.泛型
声明处型变（declaration-site variance）与类型投影（type projections）
<font color="#dd00">A.向编译器解释这种情况。这称为声明处型变
我们可以标注 Source 的类型参数 T 来确保它仅从 Source<T> 成员中返回（生产），并从不被消费。 为此，我们提供 out 修饰符</font>

```
interface Source<out T> {
    fun nextT(): T
}

fun demo(strs: Source<String>) {
    val objects: Source<Any> = strs // 这个没问题，因为 T 是一个 out-参数
    // ……
}
```
一般原则是：当一个类 C 的类型参数 T 被声明为 out 时，它就只能出现在 C 的成员的输出-位置，但回报是 C<Base> 可以安全地作为 C<Derived>的超类。
简而言之，他们说类 C 是在参数 T 上是协变的，或者说 T 是一个协变的类型参数。 你可以认为 C 是 T 的生产者，而不是 T 的消费者。

另外除了 out，Kotlin 又补充了一个型变注释：in。它使得一个类型参数逆变：只可以被消费而不可以被生产。逆变类型的一个很好的例子是 Comparable：
```
interface Comparable<in T> {
    operator fun compareTo(other: T): Int
}

fun demo(x: Comparable<Number>) {
    x.compareTo(1.0) // 1.0 拥有类型 Double，它是 Number 的子类型
    // 因此，我们可以将 x 赋给类型为 Comparable <Double> 的变量
    val y: Comparable<Double> = x // OK！
}
```
<font color="#dd00">B.使用处型变：类型投影</font>
```
class Array<T>(val size: Int) {
    fun get(index: Int): T { …… }
    fun set(index: Int, value: T) { …… }
}
fun copy(from: Array<out Any>, to: Array<Any>) { …… }
```
这里发生的事情称为类型投影：我们说from不仅仅是一个数组，而是一个受限制的（投影的）数组：我们只可以调用返回类型为类型参数 T 的方法，如上，这意味着我们只能调用 get()。这就是我们的使用处型变的用法，并且是对应于 Java 的 Array<? extends Object>、 但使用更简单些的方式。

使用 in 投影一个类型：
```
fun fill(dest: Array<in String>, value: String) { …… }
Array<in String> 对应于 Java 的 Array<? super String>，也就是说，你可以传递一个 CharSequence 数组或一个 Object 数组给 fill() 函数。
```
<font color="#dd00">C.星投影</font>
# 
* 对于 Foo <out T : TUpper>T 是一个具有上界 TUpper 的协变类型参数   Foo <*> 等价于 Foo <out TUpper>,这意味着当 T 未知时，你可以安全地从 Foo <*> 读取 TUpper 的值

* 对于 Foo <in T>，其中 T 是一个逆变类型参数,Foo <*> 等价于 Foo <in Nothing>这意味着当 T 未知时，没有什么可以以安全的方式写入 Foo <*>

* 对于 Foo <T : TUpper>，其中 T 是一个具有上界 TUpper 的不型变类型参数，Foo<*> 对于读取值时等价于 Foo<out TUpper> 而对于写值时等价于 Foo<in Nothing>。

如果泛型类型具有多个类型参数，则每个类型参数都可以单独投影。 例如，如果类型被声明为 interface Function <in T, out U>
* Function<*, String> 表示 Function<in Nothing, String>；
* Function<Int, *> 表示 Function<Int, out Any?>；
* Function<*, *> 表示 Function<in Nothing, out Any?>。
星投影非常像 Java 的原始类型，但是安全

<font color="#dd00">D.泛型函数</font>
不仅类可以有类型参数。函数也可以有。类型参数要放在函数名称之前：
```
fun <T> singletonList(item: T): List<T> {
    // ……
}
```
<font color="#dd00">E.泛型约束</font>
能够替换给定类型参数的所有可能类型的集合可以由泛型约束限制。

最常见的约束类型是与 Java 的 extends 关键字对应的 上界：
```
fun <T : Comparable<T>> sort(list: List<T>) {  …… }
```
冒号之后指定的类型是上界：只有 Comparable<T> 的子类型可以替代 T
```
sort(listOf(1, 2, 3)) // OK。Int 是 Comparable<Int> 的子类型
sort(listOf(HashMap<Int, String>())) // 错误：HashMap<Int, String> 不是Comparable<HashMap<Int, String>> 的子类型
```
默认的上界（如果没有声明）是 Any?。在尖括号中只能指定一个上界。 如果同一类型参数需要多个上界，我们需要一个单独的 where-子句：
```
fun <T> copyWhenGreater(list: List<T>, threshold: T): List<String>
    where T : CharSequence,
          T : Comparable<T> {
    return list.filter { it > threshold }.map { it.toString() }
}
```
所传递的类型必须同时满足 where 子句的所有条件。在上述示例中，类型 T 必须既实现了 CharSequence 也实现了 Comparable

<font color="#dd00">F.类型擦除</font>
Kotlin 为泛型声明用法执行的类型安全检测仅在编译期进行。 运行时泛型类型的实例不保留关于其类型实参的任何信息。 其类型信息称为被擦除。例如，Foo<Bar> 与 Foo<Baz?> 的实例都会被擦除为 Foo<*>。
因此，并没有通用的方法在运行时检测一个泛型类型的实例是否通过指定类型参数所创建 ，并且编译器禁止这种 is 检测。
类型转换为带有具体类型参数的泛型类型，如 foo as List<String> 无法在运行时检测。 当高级程序逻辑隐含了类型转换的类型安全而无法直接通过编译器推断时， 可以使用这种非受检类型转换。编译器会对非受检类型转换发出警告，并且在运行时只对非泛型部分检测（相当于 foo as List<*>）。
泛型函数调用的类型参数也同样只在编译期检测。在函数体内部， 类型参数不能用于类型检测，并且类型转换为类型参数（foo as T）也是非受检的。然而， 内联函数的具体化的类型参数会由调用处内联函数体中的类型实参所代入，因此可以用于类型检测与转换， 与上述泛型类型的实例具有相同限制。

# 12.嵌套类
<font color="#dd00">A.内部类</font>
标记为 inner 的嵌套类能够访问其外部类的成员。内部类会带有一个对外部类的对象的引用：
```
class Outer {
    private val bar: Int = 1
    inner class Inner {
        fun foo() = bar
    }
}

val demo = Outer().Inner().foo() // == 1
```

<font color="#dd00">B.匿名内部类</font>
```
window.addMouseListener(object : MouseAdapter() {

    override fun mouseClicked(e: MouseEvent) { …… }

    override fun mouseEntered(e: MouseEvent) { …… }
})
```
注：对于 JVM 平台, 如果对象是函数式 Java 接口（即具有单个抽象方法的 Java 接口）的实例， 你可以使用带接口类型前缀的lambda表达式创建它：
```
val listener = ActionListener { println("clicked") }
```
# 13.对象表达式与对象声明. object:
<font color="#dd00">A.对象表达式,要创建一个继承自某个（或某些）类型的匿名类的对象</font>
```
window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) { /*……*/ }

    override fun mouseEntered(e: MouseEvent) { /*……*/ }
})
```
<font color="#dd00">B.如果超类型有一个构造函数，则必须传递适当的构造函数参数给它。 多个超类型可以由跟在冒号后面的逗号分隔的列表指定：</font>
```
open class A(x: Int) {
    public open val y: Int = x
}

interface B { /*……*/ }

val ab: A = object : A(1), B {
    override val y = 15
}
```
<font color="#dd00">C.如果我们只需要“一个对象而已”，并不需要特殊超类型，那么我们可以简单地写：</font>
```
fun foo() {
    val adHoc = object {
        var x: Int = 0
        var y: Int = 0
    }
    print(adHoc.x + adHoc.y)
}
```

<font color="#dd00">D.请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的返回类型或者用作公有属性的类型，那么该函数或属性的实际类型会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象中添加的成员将无法访问</font>
```

class C {
    // 私有函数，所以其返回类型是匿名对象类型
    private fun foo() = object {
        val x: String = "x"
    }

    // 公有函数，所以其返回类型是 Any
    fun publicFoo() = object {
        val x: String = "x"
    }

    fun bar() {
        val x1 = foo().x        // 没问题
        val x2 = publicFoo().x  // 错误：未能解析的引用“x”
    }
}
```
<font color="#dd00">E.对象声明</font>
```
单例声明
object DataProviderManager {
    fun registerDataProvider(provider: DataProvider) {
        // ……
    }

    val allDataProviders: Collection<DataProvider>
        get() = // ……
}
```
对象声明的初始化过程是线程安全的。

<font color="#dd00">F.伴生对象</font>
```
类内部的对象声明可以用 companion 关键字标记：
class MyClass {
    companion object Factory { //可以省略伴生对象的名称Factory
        fun create(): MyClass = MyClass()
    }
}

class MyClass {
    companion object { }
}

val x = MyClass.Companion
```
请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且，例如还可以实现接口：
```
interface Factory<T> {
    fun create(): T
}

class MyClass {
    companion object : Factory<MyClass> {
        override fun create(): MyClass = MyClass()
    }
}

val f: Factory<MyClass> = MyClass
```
当然，在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段

# 14.类型别名
typealias NodeSet = Set<Network.Node>
类型别名不会引入新类型。 它们等效于相应的底层类型。 当你在代码中添加 typealias Predicate<T> 并使用 Predicate<Int> 时，Kotlin 编译器总是把它扩展为 (Int) -> Boolean。 因此，当你需要泛型函数类型时，你可以传递该类型的变量，反之亦然：
```
typealias Predicate<T> = (T) -> Boolean

fun foo(p: Predicate<Int>) = p(42)

fun main() {
    val f: (Int) -> Boolean = { it > 0 }
    println(foo(f)) // 输出 "true"

    val p: Predicate<Int> = { it > 0 }
    println(listOf(1, -2).filter(p)) // 输出 "[1]"
}
```
# 15.委托
委托模式已经证明是实现继承的一个很好的替代方式
Derived 的超类型列表中的 by-子句表示 b 将会在 Derived 中内部存储， 并且编译器将生成转发给 b 的所有 Base 的方法
```
interface Base {
    fun printMessage()
    fun printMessageLine()
}

class BaseImpl(val x: Int) : Base {
    override fun printMessage() { print(x) }
    override fun printMessageLine() { println(x) }
}

class Derived(b: Base) : Base by b {
    override fun printMessage() { print("abc") }
}

fun main() {
    val b = BaseImpl(10)
    Derived(b).printMessage()
    Derived(b).printMessageLine()
}
```
覆盖::编译器会使用 override 覆盖的实现而不是委托对象中的。如果将 override fun printMessage() { print("abc") } 添加到 Derived，那么当调用 printMessage 时程序会输出“abc”而不是“10”：

# 16.委托属性
有一些常见的属性类型，虽然我们可以在每次需要的时候手动实现它们， 但是如果能够为大家把他们只实现一次并放入一个库会更好。例如包括：  

* 延迟属性（lazy properties）: 其值只在首次访问时计算；
* 可观察属性（observable properties）: 监听器会收到有关此属性变更的通知；
* 把多个属性储存在一个映射（map）中，而不是每个存在单独的字段中。

<font color="#dd00">A.为了涵盖这些（以及其他）情况，Kotlin 支持 委托属性:</font>
```
class Example {
    var p: String by Delegate()
}
```
语法是： val/var <属性名>: <类型> by <表达式>。在 by 后面的表达式是该 委托， 因为属性对应的 get()（与 set()）会被委托给它的 getValue() 与 setValue() 方法。 属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（与 setValue()——对于 var 属性）。
委托类可以实现包含所需 operator 方法的 ReadOnlyProperty 或 ReadWriteProperty 接口之一。 这俩接
 例如:
 ```
class Delegate {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        return "$thisRef, thank you for delegating '${property.name}' to me!"
    }
 
    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        println("$value has been assigned to '${property.name}' in $thisRef.")
    }
}

val e = Example()
println(e.p)
e.p = "NEW"
```
<font color="#dd00">B.延迟属性 Lazy</font>
```
lazy() 是接受一个 lambda 并返回一个 Lazy <T> 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果
val lazyValue: String by lazy {
    println("computed!")
    "Hello"
}

fun main() {
    println(lazyValue)
    println(lazyValue)
}
```
默认情况下，对于 lazy 属性的求值是同步锁的（synchronized）：该值只在一个线程中计算，并且所有线程会看到相同的值。如果初始化委托的同步锁不是必需的，这样多个线程可以同时执行，那么将 LazyThreadSafetyMode.PUBLICATION 作为参数传递给 lazy() 函数。 而如果你确定初始化将总是发生在与属性使用位于相同的线程， 那么可以使用 LazyThreadSafetyMode.NONE 模式：它不会有任何线程安全的保证以及相关的开销。

<font color="#dd00">C.可观察属性 Observable</font>
```
Delegates.observable() 接受两个参数：初始值与修改时处理程序（handler）。 每当我们给属性赋值时会调用该处理程序（在赋值后执行）。它有三个参数：被赋值的属性、旧值与新值：
class User {
    var name: String by Delegates.observable("<no name>") {
        prop, old, new ->
        println("$old -> $new")
    }
}

fun main() {
    val user = User()
    user.name = "first"
    user.name = "second"
}
```
如果你想截获赋值并“否决”它们，那么使用 vetoable() 取代 observable()。 在属性被赋新值生效之前会调用传递给 vetoable 的处理程序。

<font color="#dd00">D.把属性储存在映射中</font>
```
一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者做其他“动态”事情的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性
class User(val map: Map<String, Any?>) {
    val name: String by map
    val age: Int     by map
}
val user = User(mapOf(
    "name" to "John Doe",
    "age"  to 25
))
println(user.name) // Prints "John Doe"
println(user.age)  // Prints 25
这也适用于 var 属性，如果把只读的 Map 换成 MutableMap 的话
class MutableUser(val map: MutableMap<String, Any?>) {
    var name: String by map
    var age: Int     by map
}
```
# 17.函数
<font color="#dd00">A.默认参数</font>
函数参数可以有默认值，当省略相应的参数时使用默认值。与其他语言相比，这可以减少重载数量：
```
fun read(b: Array<Byte>, off: Int = 0, len: Int = b.size) { /*……*/ }
```
覆盖方法总是使用与基类型方法相同的默认参数值。 当覆盖一个带有默认参数值的方法时，必须从签名中省略默认参数值：
```
open class A {
    open fun foo(i: Int = 10) { /*……*/ }
}

class B : A() {
    override fun foo(i: Int) { /*……*/ }  // 不能有默认值
}
```
如果一个默认参数在一个无默认值的参数之前，那么该默认值只能通过使用命名参数调用该函数来使用：
```
fun foo(bar: Int = 0, baz: Int) { /*……*/ }

foo(baz = 1) // 使用默认值 bar = 0
```
如果在默认参数之后的最后一个参数是 lambda 表达式，那么它既可以作为命名参数在括号内传入，也可以在括号外传入：
```
fun foo(bar: Int = 0, baz: Int = 1, qux: () -> Unit) { /*……*/ }

foo(1) { println("hello") }     // 使用默认值 baz = 1
foo(qux = { println("hello") }) // 使用两个默认值 bar = 0 与 baz = 1
foo { println("hello") }        // 使用两个默认值 bar = 0 与 baz = 1
```
<font color="#dd00">B.命名参数</font>
可以在调用函数时使用命名的函数参数。当一个函数有大量的参数或默认参数时这会非常方便。
```
fun reformat(str: String,
             normalizeCase: Boolean = true,
             upperCaseFirstLetter: Boolean = true,
             divideByCamelHumps: Boolean = false,
             wordSeparator: Char = ' ') {
/*……*/
}

使用默认参数来调用它：
reformat(str)
使用非默认参数调用它时
reformat(str, true, true, false, '_')
使用命名参数我们可以使代码更具有可读性：
reformat(str,
    normalizeCase = true,
    upperCaseFirstLetter = true,
    divideByCamelHumps = false,
    wordSeparator = '_'
)
如果我们不需要所有的参数
reformat(str, wordSeparator = '_')
```
当一个函数调用混用位置参数与命名参数时，所有位置参数都要放在第一个命名参数之前。例如，允许调用 f(1, y = 2) 但不允许 f(x = 1, 2)

可以通过使用星号操作符将可变数量参数（vararg） 以命名形式传入：
```
un foo(vararg strings: String) { /*……*/ }

foo(strings = *arrayOf("a", "b", "c"))
```
<font color="#dd00">C.返回 Unit 的函数</font>
如果一个函数不返回任何有用的值，它的返回类型是 Unit。Unit 是一种只有一个值——Unit 的类型。这个值不需要显式返回：
```
fun printHello(name: String?): Unit {
    if (name != null)
        println("Hello ${name}")
    else
        println("Hi there!")
    // `return Unit` 或者 `return` 是可选的
}
```
Unit 返回类型声明也是可选的,可省略不写

<font color="#dd00">D.单表达式函数</font>
当函数返回单个表达式时，可以省略花括号并且在 = 符号之后指定代码体即可
```
fun double(x: Int): Int = x * 2
```
<font color="#dd00">E.可变数量的参数（Varargs）</font>
```
fun <T> asList(vararg ts: T): List<T> {
    val result = ArrayList<T>()
    for (t in ts) // ts is an Array
        result.add(t)
    return result
}
val list = asList(1, 2, 3)
```
<font color="#dd00">F.尾递归函数</font>
这允许一些通常用循环写的算法改用递归函数来写，而无堆栈溢出的风险。 当一个函数用 tailrec 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本：
```
val eps = 1E-10 // "good enough", could be 10^-15

tailrec fun findFixPoint(x: Double = 1.0): Double
        = if (Math.abs(x - Math.cos(x)) < eps) x else findFixPoint(Math.cos(x))
```
<font color="#dd00">G.高阶函数</font>
高阶函数是将函数用作参数或返回值的函数。
```
fun <T, R> Collection<T>.fold(initial: R, combine: (acc: R, nextElement: T) -> R): R {
    var accumulator: R = initial
    for (element: T in this) {
        accumulator = combine(accumulator, element)
    }
    return accumulator
}
```
在上述代码中，参数 combine 具有函数类型 (R, T) -> R，因此 fold 接受一个函数作为参数， 该函数接受类型分别为 R 与 T 的两个参数并返回一个 R 类型的值。 在 for-循环内部调用该函数，然后将其返回值赋值给 accumulator

<font color="#dd00">H.函数类型</font>
类似 (Int) -> String 的一系列函数类型来处理函数的声明： val onClick: () -> Unit = ……。

* 1.所有函数类型都有一个圆括号括起来的参数类型列表以及一个返回类型：(A, B) -> C
* 2.函数类型可以有一个额外的接收者类型，它在表示法中的点之前指定： 类型 A.(B) -> C 表示可以在 A 的接收者对象上以一个 B 类型参数来调用并返回一个 C 类型值的函数
* 3.挂起函数属于特殊种类的函数类型，它的表示法中有一个 suspend 修饰符 ，例如 suspend () -> Unit 或者 suspend A.(B) -> C。
```
如需将函数类型指定为可空，请使用圆括号：((Int, Int) -> Int)?。
函数类型可以使用圆括号进行接合：(Int) -> ((Int) -> Unit)
箭头表示法是右结合的，(Int) -> (Int) -> Unit 与前述示例等价，但不等于 ((Int) -> (Int)) -> Unit。
```

<font color="#dd00">I.函数类型实例化</font>
```
lambda 表达式: { a, b -> a + b },
匿名函数: fun(s: String): Int { return s.toIntOrNull() ?: 0 }

如果有足够信息，编译器可以推断变量的函数类型：
val a = { i: Int -> i + 1 } // 推断出的类型是 (Int) -> Int
```

<font color="#dd00">J.使用已有声明的可调用引用</font>
# 
* 顶层、局部、成员、扩展函数：::isOdd、 String::toInt，
* 顶层、成员、扩展属性：List<Int>::size，
* 构造函数：::Regex

```
val stringPlus: (String, String) -> String = String::plus
val intPlus: Int.(Int) -> Int = Int::plus

println(stringPlus.invoke("<-", "->"))
println(stringPlus("Hello, ", "world!")) 

println(intPlus.invoke(1, 1))
println(intPlus(1, 2))
println(2.intPlus(3)) // 类扩展调用
```
<font color="#dd00">K.如果函数的最后一个参数是函数，那么作为相应参数传入的 lambda 表达式可以放在圆括号之外：拖尾 lambda 表达式。</font>
```
val product = items.fold(1) { acc, e -> acc * e }
如果该 lambda 表达式是调用时唯一的参数，那么圆括号可以完全省略：
run { println("...") }
```

<font color="#dd00">M.从 lambda 表达式中返回一个值</font>
我们可以使用限定的返回语法从 lambda 显式返回一个值。 否则，将隐式返回最后一个表达式的值。
因此，以下两个片段是等价的：
```
ints.filter {
    val shouldFilter = it > 0 
    shouldFilter
}

ints.filter {
    val shouldFilter = it > 0 
    return@filter shouldFilter
}
```

<font color="#dd00">N.如果 lambda 表达式的参数未使用，那么可以用下划线取代其名称：</font>
```
map.forEach { _, value -> println("$value!") }
```

<font color="#dd00">O.匿名函数</font>
```
fun(x: Int, y: Int): Int = x + y
```
匿名函数参数总是在括号内传递。 允许将函数留在圆括号外的简写语法仅适用于 lambda 表达式。

<font color="#dd00">P.带有接收者的函数字面值</font>
```
带有接收者的函数字面值及其类型的示例
val sum: Int.(Int) -> Int = { other -> plus(other) }
匿名函数语法允许你直接指定函数字面值的接收者类型。 如果你需要使用带接收者的函数类型声明一个变量，并在之后使用它，这将非常有用
val sum = fun Int.(other: Int): Int = this + other
当接收者类型可以从上下文推断时，lambda 表达式可以用作带接收者的函数字面值
class HTML {
    fun body() { …… }
}

fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()  // 创建接收者对象
    html.init()        // 将该接收者对象传给该 lambda
    return html
}

html {       // 带接收者的 lambda 由此开始
    body()   // 调用该接收者对象的一个方法
}
```

<font color="#dd00">Q.内联函数</font>
#
使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。 即那些在函数体内会访问到的变量。 内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。
但是在许多情况下通过内联化 lambda 表达式可以消除这类的开销
```
inline fun <T> lock(lock: Lock, body: () -> T): T { …… }
lock(l) { foo() }
编译器没有为参数创建一个函数对象并生成一个调用。取而代之，编译器可以生成以下代码：
l.lock()
try {
    foo()
}
finally {
    l.unlock()
}
内联可能导致生成的代码增加；不过如果我们使用得当（即避免内联过大函数），性能上会有所提升，尤其是在循环中的“超多态（megamorphic）”调用处。

fun foo() {
    ordinaryFunction {
        return // 错误：不能使 `foo` 在此处返回
    }
}

fun foo() {
    inlined {
        return // OK：该 lambda 表达式是内联的
    }
}
```

# 18.集合 
* 		List 是一个有序集合，可通过索引（反映元素位置的整数）访问元素。元素可以在 list 中出现多次。列表的一个示例是一句话：有一组字、这些字的顺序很重要并且字可以重复。
* 		Set 是唯一元素的集合。它反映了集合（set）的数学抽象：一组无重复的对象。一般来说 set 中元素的顺序并不重要。例如，字母表是字母的集合（set）。
* 		Map（或者字典）是一组键值对。键是唯一的，每个键都刚好映射到一个值。值可以重复。map 对于存储对象之间的逻辑连接非常有用，例如，员工的 ID 与员工的位置。
* 

只读集合类型是型变的。 这意味着，如果类 Rectangle 继承自 Shape，则可以在需要 List <Shape> 的任何地方使用 List <Rectangle>。 换句话说，集合类型与元素类型具有相同的子类型关系。 map 在值（value）类型上是型变的，但在键（key）类型上不是。
反之，可变集合不是型变的；否则将导致运行时故障。 如果 MutableList <Rectangle> 是 MutableList <Shape> 的子类型，你可以在其中插入其他 Shape 的继承者（例如，Circle），从而违反了它的 Rectangle 类型参数。

<font color="#dd00">A.集合转换</font>
```
val numbers = setOf(1, 2, 3)
println(numbers.map { it * 3 })
```

<font color="#dd00">B.双路合并</font>
```
val colors = listOf("red", "brown", "grey")
val animals = listOf("fox", "bear", "wolf")
println(colors zip animals)

val twoAnimals = listOf("fox", "bear")
println(colors.zip(twoAnimals))
```
<font color="#dd00">C.字符串表示   joinToString() and joinTo().</font>
```
al numbers = listOf("one", "two", "three", "four")

println(numbers)         
println(numbers.joinToString())

val listString = StringBuffer("The list of numbers: ")
numbers.joinTo(listString)
println(listString)
```

<font color="#dd00">D.按谓词过滤</font>
```
val numbers = listOf("one", "two", "three", "four")  
val longerThan3 = numbers.filter { it.length > 3 }
println(longerThan3)

val numbersMap = mapOf("key1" to 1, "key2" to 2, "key3" to 3, "key11" to 11)
val filteredMap = numbersMap.filter { (key, value) -> key.endsWith("1") && value > 10}
println(filteredMap)

val numbers = listOf(null, 1, "two", 3.0, "four")
println("All String elements in upper case:")
numbers.filterIsInstance<String>().forEach {
    println(it.toUpperCase())
}
```

<font color="#dd00">E.划分</font>
```
val numbers = listOf("one", "two", "three", "four")
val (match, rest) = numbers.partition { it.length > 3 }

println(match)
println(rest)
```

<font color="#dd00">F.分组</font>
```
val numbers = listOf("one", "two", "three", "four", "five")

println(numbers.groupBy { it.first().toUpperCase() })
println(numbers.groupBy(keySelector = { it.first() }, valueTransform = { it.toUpperCase() }))
```

<font color="#dd00">G.取单个元素</font>
```
val numbers = linkedSetOf("one", "two", "three", "four", "five")
println(numbers.elementAt(3))   

val numbers = listOf("one", "two", "three", "four", "five", "six")
println(numbers.first())    
println(numbers.last())
println(numbers.first { it.length > 3 })
println(numbers.firstOrNull { it.length > 6 })
println(numbers.find { it % 2 == 0 })
println(numbers.contains("four”))//检测是否存在
```

<font color="#dd00">19.从函数中返回两个变量</font>
```
data class Result(val result: Int, val status: Status)
fun function(……): Result {
    // 各种计算

    return Result(result, status)
}
```
// 现在，使用该函数：
val (result, status) = function(……)
因为数据类自动声明 componentN() 函数，所以这里可以用解构声明

解构声明和映射

# 20.类型检测与类型转换：“is”与“as”
```
is 与 !is 操作符

if (obj is String) {
    print(obj.length)
}
“不安全的”转换操作符
val x: String = y as String
“安全的”（可空）转换操作符
val x: String? = y as? String
```

# 21.Elvis 操作符
val l = b?.length ?: -1
如果 ?: 左侧表达式非空，elvis 操作符就返回其左侧表达式，否则返回右侧表达式。 请注意，当且仅当左侧为空时，才会对右侧表达式求值。

# 22.异常类
```
try {
    // 一些代码
}
catch (e: SomeException) {
    // 处理程序
}
finally {
    // 可选的 finally 块
}
```
try-表达式的返回值是 try 块中的最后一个表达式或者是（所有）catch 块中的最后一个表达式。 finally 块中的内容不会影响表达式的结果。

# 23.作用域函数
let、run、with、apply 以及 also
run、with 以及 apply 通过关键字 this 引用上下文对象。因此，在它们的 lambda 表达式中可以像在普通的类函数中一样访问上下文对象。在大多数场景，当你访问接收者对象时你可以省略 this，来让你的代码更简短。
根据返回结果，作用域函数可以分为以下两类：
* apply 及 also 返回上下文对象。
* let、run 及 with 返回 lambda 表达式结果.(最后一个表达式的结果)
```
val numbers = mutableListOf("one", "two", "three")
with(numbers) {
    println("'with' is called with argument $this")
    println("It contains $size elements")
}
```
当以提供的谓词在对象上进行调用时，若该对象与谓词匹配，则 takeIf 返回此对象。否则返回 null。因此，takeIf 是单个对象的过滤函数。反之，takeUnless如果不匹配谓词，则返回对象，如果匹配则返回 null。该对象作为 lambda 表达式参数（it）来访问。
```
val number = Random.nextInt(100)

val evenOrNull = number.takeIf { it % 2 == 0 }
val oddOrNull = number.takeUnless { it % 2 == 0 }
val str = "Hello”.takeif{it.isNotEmpty()}?.toUpperCase()
```
# 24.协程
```
 GlobalScope.launch { // 在后台启动一个新的协程并继续
        delay(1000L)
        println("World!")
    }
    println("Hello,") // 主线程中的代码会立即执行
    runBlocking {     // 但是这个表达式阻塞了主线程
        delay(2000L)  // ……我们延迟 2 秒来保证 JVM 的存活
    }
    
```
延迟一段时间来等待另一个协程运行并不是一个好的选择。让我们显式（以非阻塞方式）等待所启动的后台 Job 执行结束：
```
val job = GlobalScope.launch { // 启动一个新协程并保持对这个作业的引用
    delay(1000L)
    println("World!")
}
println("Hello,")
job.join() // 等待直到子协程执行结束
```
使用 runBlocking 协程构建器将 main 函数转换为协程,因为外部协程（示例中的 runBlocking）直到在其作用域中启动的所有协程都执行完毕后才会结束,可以将我们的示例简化为:
```
fun main() = runBlocking { // this: CoroutineScope
    launch { // 在 runBlocking 作用域中启动一个新协程
        delay(1000L)
        println("World!")
    }
    println("Hello,")
}
```
作用域构建器
除了由不同的构建器提供协程作用域之外，还可以使用 coroutineScope 构建器声明自己的作用域。它会创建一个协程作用域并且在所有已启动子协程执行完毕之前不会结束。runBlocking 与 coroutineScope 的主要区别在于后者在等待所有子协程执行完毕时不会阻塞当前线程。
```
fun main() = runBlocking { // this: CoroutineScope
    launch { 
        delay(200L)
        println("Task from runBlocking")
    }
    
    coroutineScope { // 创建一个协程作用域
        launch {
            delay(500L) 
            println("Task from nested launch")
        }
    
        delay(100L)
        println("Task from coroutine scope") // 这一行会在内嵌 launch 之前输出
    }
    
    println("Coroutine scope is over") // 这一行在内嵌 launch 执行完毕后才输出
}
```
当你对这段代码执行“提取函数”重构时，你会得到一个带有 suspend 修饰符的新函数。 那是你的第一个挂起函数。在协程内部可以像普通函数一样使用挂起函数， 不过其额外特性是，同样可以使用其他挂起函数（如本例中的 delay）来挂起协程的执行。
```
fun main() = runBlocking {
    launch { doWorld() }
    println("Hello,")
}

// 这是你的第一个挂起函数
suspend fun doWorld() {
    delay(1000L)
    println("World!")
}

协程很轻量
fun main() = runBlocking {
    repeat(100_000) { // 启动大量的协程
        launch {
            delay(1000L)
            print(".")
        }
    }
}
```
它启动了 10 万个协程，并且在一秒钟后，每个协程都输出一个点。 现在，尝试使用线程来实现。会发生什么？（很可能你的代码会产生某种内存不足的错误）

async 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。
```
val time = measureTimeMillis {
    val one = async { doSomethingUsefulOne() }
    val two = async { doSomethingUsefulTwo() }
    println("The answer is ${one.await() + two.await()}")
}
```
调度器与线程
```
launch { // 运行在父协程的上下文中，即 runBlocking 主协程
    println("main runBlocking      : I'm working in thread ${Thread.currentThread().name}")
}
launch(Dispatchers.Unconfined) { // 不受限的——将工作在主线程中
    println("Unconfined            : I'm working in thread ${Thread.currentThread().name}")
}
launch(Dispatchers.Default) { // 将会获取默认调度器
    println("Default               : I'm working in thread ${Thread.currentThread().name}")
}
launch(newSingleThreadContext("MyOwnThread")) { // 将使它获得一个新的线程
    println("newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}")
}
```

