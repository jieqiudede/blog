---
layout: post
title: Retrofit
---
# 1.简介  
 <img src="https://github.com/jieqiudede/blog/blob/gh-pages/image/retrofit-1.png?raw=true" width="100%">  

> 特别注意:  
   * 准确来说，Retrofit是一个RESTful的HTTP网络请求框架的封装。
   * 原因：网络请求的工作本质上是OkHttp完成，而Retrofit仅负责网络请求接口的封装  
   * App应用程序通过 Retrofit 请求网络，实际上是使用 Retrofit 接口层封装请求参数、Header、Url 等信息，之后由 OkHttp 完成后续的请求操作
   * 在服务端返回数据之后，OkHttp 将原始的结果交给 Retrofit，Retrofit根据用户的需求对结果进行解析  

<img src="https://github.com/jieqiudede/blog/blob/gh-pages/image/retrofit-2.png?raw=true">  
> 
# 创建 用于描述网络请求 的接口  
 * Retrofit将Http请求抽象成Java接口：采用***注解***描述网络请求参数和配置网络请求参数  
 * 用***动态代理***使用create（)方法将该接口的注解“翻译”成一个Http请求，最后再执行Http请求  
 * 注：接口中的每个方法的参数都需要使用注解标注，否则会报错  
  
 <img src="https://github.com/jieqiudede/blog/blob/gh-pages/image/Retrofit.png?raw=true">  

# 角色
 <img src="https://github.com/jieqiudede/blog/blob/gh-pages/image/retrofit-3.png?raw=true">  

> 
# 创建网络接口实例用了外观模式 & 代理模式：  
> AccessApi NetService = retrofit.create(NetService.class);  
  * 外观模式:  
  > * 1.Retrofit对象的外观（门店） = retrofit.create()  
  > * 2.通过这一外观方法就可以在内部调用各个方法创建网络请求接口的实例和配置网络请求参数,大大降低了系统的耦合度  
> * 代理模式  
  > * return (T) roxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler invocationHandler)通过代理模式中的动态代理模式，动态生成网络请求接口的代理类，并将代理类的实例创建交给InvocationHandler类 作为具体的实现，并最终返回一个动态代理对象。 
生成实例过程中含有生成实现类的缓存机制（单例模式)  
> 使用动态代理的好处：  
  * 当NetService对象调用getCall（）接口中方法时会进行拦截，调用都会集中转发到 InvocationHandler#invoke （），可集中进行处理  
  * 获得网络请求接口实例上的所有注解  
  * 更方便封装ServiceMethod  
  > * ServiceMethod几乎保存了一个网络请求所需要的数据
  > * 发送网络请求时，OkHttpCall需要从ServiceMethod中获得一个Request对象
  > * 解析数据时，还需要通过ServiceMethod使用Converter（数据转换器）转换成Java对象进行数据解析
  > * 为了提高效率，Retrofit还会对解析过的请求ServiceMethod进行缓存，存放在Map<Method, ServiceMethod> serviceMethodCache = new LinkedHashMap<>();对象中，即第二步提到的单例模式 

# 总结  
> Retrofit采用了 外观模式 统一调用创建网络请求接口实例和网络请求参数配置的方法，具体细节是:  
* 动态创建网络请求接口的实例（代理模式 - 动态代理)  
* 创建 serviceMethod 对象（建造者模式 & 单例模式（缓存机制））  
* 对 serviceMethod 对象进行网络请求参数配置：通过解析网络请求接口方法的参数、返回值和注解类型，从Retrofit对象中获取对应的网络请求的url地址、网络请求执行器、网络请求适配器 & 数据转换器。（策略模式）  
* 对 serviceMethod 对象加入线程切换的操作，便于接收数据后通过Handler从子线程切换到主线程从而对返回数据结果进行处理（装饰模式）  
* 最终创建并返回一个OkHttpCall类型的网络请求对象  

> 

# 最后贴一张非常详细的Retrofit源码分析图：  
<img src="https://github.com/jieqiudede/blog/blob/gh-pages/image/retrofit-4.png?raw=true" width="100%">  

