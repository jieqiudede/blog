---
layout: post
title: JVM内存相关问题
# 哪些内存需要回收?
> 
* （1).引用计数法：判断对象的引用数量
*  (2).可达性分析算法：判断对象的引用链是否可达

# 垃圾收集算法
> 
 * (1)标记清除算法,分为标记和清除两个阶段。该算法首先从根集合进行扫描，对存活的对象进行标记，玩标记完毕后，再扫描整个空间未被标记的对象进行回收.效率都不高,不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，
  *  (2)复制算法 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉

 * (3)标记整理算法的标记过程类似标记清楚算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景(老年代)

 * (4)分代收集算法.  新生代对象存活率低，就采用复制算法；老年代存活率高，就采用标记清楚算法或者标记整理算法。Java堆内存一般可以分为新生代、老年代和永久带三个模块  
> 
* (a)新生代(Young Generation)
    >  新生代发生的GC也叫MinorGC，MinorGC发生频率比较高，不一定等到Eden区满了才触发
* (b)老年代(Old Generation)
   >  在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。此外，老年代的内存也比新生代大很多，大概比例是(1:2)，当老年代满时会触发Major GC/Full GC，老年代对象存活时间比较长，因此Major GC/Full GC发生的频率比较低。
*  (c)永久代(Permanent Generation)
   > 永久代主要用于存放静态文件，如Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如使用反射、动态代理、GCLib等bytecode框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类  
# 小结:  
> 由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。垃圾回收有两种类型，Minor GC 和Major GC/Full GC。
* Minor GC：对新生代进行回收，不会影响到老年代。因为新生代的Java对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。
* Major GC/Full GC：对整个堆进行回收，包括新生代和老年代。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代要被写满、永久代被写满和System.gc()被显式调用等。  

# 回收无效对象的过程

> 当JVM筛选出失效的对象之后，并不是立即清除，而是再给对象一次重生的机会，具体过程如下：

* 判断该对象是否覆盖了finalize()方法

> 
  * 若已覆盖该方法，并该对象的finalize()方法还没有被执行过，那么就会将finalize()扔到F-Queue队列中；
  * 若未覆盖该方法，则直接释放对象内存。执行F-Queue队列中的finalize()方法 
虚拟机会以较低的优先级执行这些finalize()方法们，也不会确保所有的finalize()方法都会执行结束。如果finalize()方法中出现耗时操作，虚拟机就直接停止执行，将该对象清除。

> ***对象重生或死亡*** 
* 如果在执行finalize()方法时，将this赋给了某一个引用，那么该对象就重生了。如果没有，那么就会被垃圾收集器清除。

> ***注意：*** 
* 强烈不建议使用finalize()函数进行任何操作！如果需要释放资源，请使用try-finally。 因为finalize()不确定性大，开销大，无法保证顺利执行。  

* [ 原文链接 ]: https://blog.csdn.net/u010425776/article/details/51189318


# 方法区的内存回收
* 生夕死”，每次垃圾回收都会清除掉大量的对象；而老年代中的对象生命较长，每次垃圾回收只有少量的对象被清除掉。

* 由于方法区中存放生命周期较长的类信息、常量、静态变量，因此方法区就像是堆的老年代，每次垃圾收集的只有少量的垃圾被清除掉。

> 方法区中主要清除两种垃圾： 
* 1. 废弃常量 
* 2. 废弃的类



> 
 * 1. 如何判定废弃常量？(常量也不一定都是存在内存的)

> 清除废弃的常量和清除对象类似，只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。



* 2. 如何废弃废弃的类？

> 清除废弃类的条件较为苛刻： 
* 1. 该类的所有对象都已被清除 
* 2. 该类的java.lang.Class对象没有被任何对象或变量引用 
只要一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载进方法区的时候创建，在方法区中该类被删除时清除。 
* 3. 加载该类的ClassLoader已经被回收

# 大对象直接进入老年代
所谓“大对象”就是指一个占用大量连续存储空间的对象，如数组。 
