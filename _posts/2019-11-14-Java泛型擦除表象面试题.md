---
layout: post
title: Java泛型擦除表象面试题(1)
---
# 1.问：下面程序块的运行结果是什么，为什么？  

```
Class c1 = new ArrayList<String>().getClass();
Class c2 = new ArrayList<String>().getClass();
System.out.println(c1 == c2);  
```
***答：*** 上面代码段结果为 true，解释如下.  
因为 load 的是同一个 class 文件，存在 ArrayList.class 文件但是不存在 ArrayList<String>.class 文件，即便是通过 class.getTypeParameters() 方法获取类型信息也只能获取到 [T] 一样的泛型参数占位符。泛型是通过擦除来实现的，所以编译后任何具体的泛型类型都被擦除了（替换为非泛型上边界，如果没有指定边界则为 Object 类型），泛型类型只有在静态类型检查期间才出现，上面都被擦除成了 ArrayList 类型，所以运行时加载的是同一个 class 文件。  

# 2.问：为什么 Java 泛型要通过擦除来实现？擦除有什么坏处或者说代价？  
***答：***可以说 Java 泛型的存在就是一个不得已的妥协，正因为这种妥协导致了 Java 泛型的混乱，甚至说是 JDK 泛型设计的失败。Java 之所以要通过擦除来实现泛型机制其实是为了兼容性考虑，只有这样才能让非泛化代码到泛化代码的转变过程建立在不破坏现有类库的实现上。正是因为这种兼容也带来了一些代价，***譬如泛型不能显式地引用运行时类型的操作之中（如向上向下转型、instanceof 操作等），因为所有关于参数的信息都丢失了，所以任何时候使用泛型都要提醒自己背后的真实擦除类型到底是什么；此外擦除和兼容性导致了使用泛型并不是强制的（如 List<String> list = new ArrayList(); 等写法）；其次擦除会导致我们在编写代码时十分谨慎（如不想被擦除为 Object 类型时不要忘了添加上边界操作等）。***  

# 3.问：下面三个 funcX 方法有问题吗，为什么？  
```
class Product <T>{
    private void func1(Object arg){
        if(arg instanceof T){}
    }
    private void func2(){
        T var = new T();
    }

    private void func3(){
        T[] vars = new T[3];
    }
}
```

***答：*** func1、func2、func3 三个方法均无法编译通过。
因为泛型擦除丢失了在泛型代码中执行某些操作的能力，任何在运行时需要知道确切类型信息的操作都将无法工作。  

# 问：下面代码段有问题吗，运行效果是什么，为什么？  
```
ArrayList<Integer> arrayList = new ArrayList<Integer>();
arrayList.add(1);
arrayList.getClass().getMethod("add", Object.class).invoke(arrayList, "abc");
for(int i = 0; i<arrayList.size();i++){
   System.out.println(arrayList.get(i));
 }
```

***答：*** 由于在程序中定义的 ArrayList 泛型类型实例化为 Integer 的对象，如果直接调用 add 方法则只能存储整形数据，不过当我们利用反射调用 add 方法时就可以存储字符串，因为 Integer 泛型实例在编译之后被擦除了，只保留了原始类型 Object，所以自然可以插入  

