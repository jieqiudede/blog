---
layout: post
title: 适配器和外观模式
---
# 1.适配器模式  
* 定义一个包装类，用于包装不兼容接口的对象  
* 把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作.  
* 适配器模式的形式分为：类的适配器模式 & 对象的适配器模式  
## 类的适配器模式  
* ###把适配的类的API转换成为目标类的API###.  
```
public interface Target {
 
    //这是源类Adapteee没有的方法
    public void Request(); 
}  
public class Adaptee {
    
    public void SpecificRequest(){
    }
}  
//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。
public class Adapter extends Adaptee implements Target {

    //目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request()
    //因此适配器补充上这个方法名
    //但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容
    //所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已
    @Override
    public void Request() {
        this.SpecificRequest();
    }

}  
public class AdapterPattern {

    public static void main(String[] args){

        Target mAdapter = new Adapter()；
        mAdapter.Request（）;
     
    }
}  
```
## 对象的适配器模式  
* 与类的适配器模式相同，对象的适配器模式也是把适配的类的API转换成为目标类的API。与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。  
```
public interface Target {
 
    //这是源类Adapteee没有的方法
    public void Request(); 
}  
public class Adaptee {
    
    public void SpecificRequest(){
    }
}  
class Adapter implements Target{  
    // 直接关联被适配类  
    private Adaptee adaptee;  
    
    // 可以通过构造函数传入具体需要适配的被适配类对象  
    public Adapter (Adaptee adaptee) {  
        this.adaptee = adaptee;  
    }  
    
    @Override
    public void Request() {  
        // 这里是使用委托的方式完成特殊功能  
        this.adaptee.SpecificRequest();  
    }  
}  
public class AdapterPattern {
    public static void main(String[] args){
        //需要先创建一个被适配类的对象作为参数  
        Target mAdapter = new Adapter(new Adaptee())；
        mAdapter.Request();
     
    }
}  

# 外观模式  
* 通过创建一个统一的外观类，用来包装子系统中一个 / 多个复杂的类，客户端可通过调用外观类的方法来调用内部子系统中所有方法  
```
//灯类
public class SubSystemA_Light {  
     public void on(){  
        System.out.println("打开了灯....");  
    }  
      
     public void off(){  
        System.out.println("关闭了灯....");  
    }  
}  

//电视类
public class SubSystemB_Television {  
     public void on(){  
        System.out.println("打开了电视....");  
    }  
      
     public void off(){  
        System.out.println("关闭了电视....");  
    }  
}  

//空调类
public class SubSystemC_Aircondition {  
     public void on(){  
        System.out.println("打开了电视....");  
    }  
      
     public void off(){  
        System.out.println("关闭了电视....");  
    }  
} 

//外观类
public class Facade{
      
      SubSystemA_Light light；
      SubSystemB_Television television ；
      SubSystemC_Aircondition aircondition；
    

      //传参
    public Facade(SubSystemA_Light light,SubSystemB_Television television,SubSystemC_Aircondition aircondition){  
        this.light = light;  
        this.television  = television ;  
        this.aircondition =aircondition;  
    
    }  
      //起床后一键开电器
      public void on{
        System.out.prinln("起床了")； 
        light.on()； 
        television.on(); 
        aircondition.on()；
    
        }

          //睡觉时一键关电器
          System.out.prinln("睡觉了")； 
          light.off()； 
          television.off(); 
          aircondition.off()； 
        }
}  
//客户端调用
public class Facade Pattern{ 
      public static void main(String[] args){
        {
            //实例化电器类
            SubSystemA_Light light = new SubSystemA_Light();
            SubSystemB_Television television = new SubSystemB_Television();
            SubSystemC_Aircondition aircondition = new SubSystemC_Aircondition();
            
            //传参
            Facade facade = new Facade(light,television,aircondition);
            
            //客户端直接与外观对象进行交互
            facade.on;
            System.out.prinln("可以看电视了")； 
            facade.off;
            System.out.prinln("可以睡觉了")； 
          }
}  
```
### 优点
  * 降低了客户类与子系统类的耦合度，实现了子系统与客户之间的松耦合关系  
  * 外观模式对客户屏蔽了子系统组件，从而简化了接口，减少了客户处理的对象数目并使子系统的使用更加简单。  
  * 降低原有系统的复杂度和系统中的编译依赖性，并简化了系统在不同平台之间的移植过程  
### 缺点  
  * 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”  
  * 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。  

> 
# 适配器和外观模式的区别  
* 外观模式的实现核心主要是——由外观类去保存各个子系统的引用，实现由一个统一的外观类去包装多个子系统类，然而客户端只需要引用这个外观类，然后由外观类来调用各个子系统中的方法。  
* 这样的实现方式非常类似适配器模式，然而外观模式与适配器模式不同的是：适配器模式是将一个对象包装起来以改变其接口，而外观是将一群对象 ”包装“起来以简化其接口。它们的意图是不一样的，适配器是将接口转换为不同接口，而外观模式是提供一个统一的接口来简化接口。  

